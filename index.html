<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>유기문어(有機文語)</title>
  <style>
    body {
      font-family: 'Pretendard', sans-serif;
      background: #1e1e1e;
      color: #ffffff;
      padding: 2em;
    }
    textarea {
      width: 100%;
      height: 200px;
      background: #2d2d2d;
      color: white;
      border: none;
      padding: 1em;
    }
    button {
      margin-top: 1em;
      padding: 0.5em 1em;
      font-size: 1em;
      background: #4caf50;
      color: white;
      border: none;
      cursor: pointer;
    }
    pre {
      background: #121212;
      padding: 1em;
      white-space: pre-wrap;
      border-left: 5px solid #4caf50;
    }
    a {
      color: #f06292;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>유기문어(有機文語)</h1>
  <textarea id="code" placeholder="여기에 유기문어 코드를 입력하세요."></textarea>
  <br />
  <button onclick="runYugimunu()">실행하기</button>
  <p style="margin-top: 1em; font-size: 0.9em;">
    프로그래밍 언어의 원작 소설이 궁금하다?<br>
    <a href="https://novelpia.com/novel/21232" target="_blank">『유기무녀』 보러가기</a>
  </p>
  <h2>실행 결과</h2>
  <pre id="output"></pre>


  <script>
    const vars = {
      "경민": 0,
      "한별": 0,
      "솔빈": 0,
      "츠카사": 0,
      "윤설": 0
    };

    const enemies = {
      "한별": ["솔빈"],
      "솔빈": ["한별"],
      "츠카사": ["윤설"],
      "윤설": ["츠카사"]
    };

    let loopStack = [];
    let conditionStack = [];


    // 주어와 목적어 구분 함수 (은/는, 이/가, 을/를 모두 처리)
    function parseSubjectAndObject(line) {
      // 주어와 목적어 구분에 사용할 패턴
      const subjectPattern = /"([\w가-힣]+)"(은|는|이|가)/; // 주어 부분
      const objectPattern = /(을|를)\s*([\w가-힣]+)/; // 목적어 부분

      // 주어와 목적어 추출
      const subjMatch = line.match(subjectPattern);
      const objMatch = line.match(objectPattern);

      if (subjMatch && objMatch) {
        const subj = subjMatch[1]; // 주어
        const obj = objMatch[2]; // 목적어
        return [subj, obj];
      }
      return [null, null]; // 주어와 목적어가 없으면 null 반환
    }

    // 주석 처리: # 뒤의 내용은 무시
    function parseLine(line) {
      if (line.trim().startsWith("#") || line.trim() === "") {
        return;  // 주석은 아무 것도 하지 않고 건너뜁니다
      }


     const output = [];

      // 변수 입력을 위한 "을 들었다" / "를 들었다" 처리
      if (line.includes("을 들었다") || line.includes("를 들었다")) {
        const match = line.match(/경민이\s+"?([\w가-힣]+)"?\s*을 들었다/);
        if (match) {
          const variable = match[1];
          vars[variable] = getInputForVariable(variable);  // 사용자로부터 값을 입력받아 변수에 저장
        }
      }

      // 비교 연산자 처리: 크다, 작다, 이해했다, 이해하지 못했다
      if (line.includes("크다")) {
        const [subj, obj] = parseSubjectAndObject(line);
        output.push(vars[subj] > vars[obj] ? "참" : "거짓");
      }
      else if (line.includes("작다")) {
        const [subj, obj] = parseSubjectAndObject(line);
        output.push(vars[subj] < vars[obj] ? "참" : "거짓");
      }
      else if (line.includes("이해했다")) {
        const [subj, obj] = parseSubjectAndObject(line);
        output.push(vars[subj] == vars[obj] ? "참" : "거짓");
      }
      else if (line.includes("이해하지 못했다")) {
        const [subj, obj] = parseSubjectAndObject(line);
        output.push(vars[subj] != vars[obj] ? "참" : "거짓");
      }

      // 변수 출력
      else if (line.includes("을 말했다") || line.includes("를 말했다")) {
        const match = line.match(/경민이\s+"?([\w가-힣]+)"?\s*을 말했다/);
        if (match) {
          const val = match[1];
          output.push(isNaN(val) ? (vars[val] ?? val) : val);
        }
      }

      // 연산자: 사랑했다 (+)
      else if (line.includes("사랑했다")) {
        const [subj, obj] = parseSubjectAndObject(line);
        if (isValidOperation(subj, obj)) {
          vars[subj] += vars[obj] ?? 1;
        }
      }

      // 연산자: 증오했다 (-)
      else if (line.includes("증오했다")) {
        const [subj, obj] = parseSubjectAndObject(line);
        if (isValidOperation(subj, obj)) {
          vars[subj] -= vars[obj] ?? 1;
        }
      }

      // 연산자: 껴안았다 (*)
      else if (line.includes("껴안았다")) {
        const [subj, obj] = parseSubjectAndObject(line);
        if (isValidOperation(subj, obj)) {
          vars[subj] *= vars[obj] ?? 1;
        }
      }

      // 연산자: 밀어냈다 (//)
      else if (line.includes("밀어냈다")) {
        const [subj, obj] = parseSubjectAndObject(line);
        if (isValidOperation(subj, obj)) {
          vars[subj] = Math.floor(vars[subj] / (vars[obj] ?? 1));
        }
      }

      // 연산자: 잊었다 (= 0)
      else if (line.includes("잊었다")) {
        const target = line.split("이 ")[0].trim();
        vars[target] = 0;
      }

      // 조건문 처리: "생각했다", "생각을 바꿨다", "생각을 그만뒀다"
      else if (line.includes("생각했다")) {
        const result = evaluateCondition(line) ? "참" : "거짓";
        output.push(result);
        conditionStack.push(evaluateCondition(line));
      } else if (line.includes("생각을 바꿨다")) {
        conditionStack.push(false);
      } else if (line.includes("생각을 그만뒀다")) {
        conditionStack.pop();
      }

      // 루프 처리: while / endwhile
      else if (line.includes("루프를 시작했다")) {
        loopStack.push(true);
      } else if (line.includes("루프를 종료했다")) {
        loopStack.pop();
      }

      // 루프 종료 조건 처리
      if (loopStack.length > 0) {
        if (loopStack[loopStack.length - 1] === false) {
          return;
        }
      }

      // 조건문 처리
      if (conditionStack.length > 0 && !conditionStack[conditionStack.length - 1]) {
        return;
      }

      return output.join("\n");
    }

    // 주어와 목적어 파싱 함수
    function parseSubjectAndObject(line) {
      const subj = line.split("이 ")[0].split("이")[0].trim();
      const obj = line.split("은")[1].split("을")[0].trim();
      return [subj, obj];
    }

    // 조건식을 평가하는 함수
    function evaluateCondition(line) {
      const match = line.match(/"(.*?)"은(.*)고 생각했다/);
      if (match) {
        const subj = match[1];
        const condition = match[2].trim();
        
        // AND(또한)와 OR(또는) 처리
        if (condition.includes("또한")) {
          const [cond1, cond2] = condition.split("또한").map(s => s.trim());
          return evaluateSimpleCondition(subj, cond1) && evaluateSimpleCondition(subj, cond2);
        }
        
        if (condition.includes("또는")) {
          const [cond1, cond2] = condition.split("또는").map(s => s.trim());
          return evaluateSimpleCondition(subj, cond1) || evaluateSimpleCondition(subj, cond2);
        }

        // 기본 조건 처리
        return evaluateSimpleCondition(subj, condition);
      }
      return false;
    }

    // 단순 조건을 평가하는 함수
    function evaluateSimpleCondition(subj, condition) {
      if (condition.includes("크다")) {
        const num = Number(condition.split("크다")[1].trim());
        return vars[subj] > num;
      }
      if (condition.includes("작다")) {
        const num = Number(condition.split("작다")[1].trim());
        return vars[subj] < num;
      }
      if (condition.includes("이해했다")) {
        const num = Number(condition.split("이해했다")[1].trim());
        return vars[subj] == num;
      }
      if (condition.includes("이해하지 못했다")) {
        const num = Number(condition.split("이해하지 못했다")[1].trim());
        return vars[subj] != num;
      }
      return false;
    }



    // 유효한 연산인지 확인하는 함수
    function isValidOperation(subj, obj) {
      // 주어와 목적어가 같을 수 없음
      if (subj === obj) {
        alert("주어와 목적어가 같을 수 없습니다.");
        return false;
      }
      // 앙숙 관계에서의 연산 제한
      if (enemies[subj] && enemies[subj].includes(obj)) {
        alert(`${subj}와 ${obj}는 적대 관계입니다. 연산을 할 수 없습니다.`);
        return false;
      }
      return true;
    }

    // 사용자 입력을 처리하는 함수
    function getInputForVariable(variable) {
      let input = prompt(`변수 ${variable}의 값을 입력하세요:`);
      if (input === "" || input === null) {
        input = 0; // 빈 입력 시 기본값 0 처리
      }
      return Number(input); // 숫자 형태로 변환
    }

    function runYugimunu() {
      const input = document.getElementById("code").value;
      const lines = input.split("\n");
      const outputArea = document.getElementById("output");
      outputArea.textContent = ""; // 초기화

      for (let line of lines) {
        if (line.trim().startsWith("#") || line.trim() === "") continue;
        try {
          const result = parseLine(line.trim());
          if (result) outputArea.textContent += result + "\n";
        } catch (e) {
          outputArea.textContent += `경민은 혼란에 빠졌다: ${e.message}\n`;
        }
      }
    }
  </script>
</body>
</html>
