<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>유기문어(有機文語)</title>
  <style>
    body {
      font-family: 'Pretendard', sans-serif;
      background: #1e1e1e;
      color: #ffffff;
      padding: 2em;
    }
    textarea {
      width: 100%;
      height: 200px;
      background: #2d2d2d;
      color: white;
      border: none;
      padding: 1em;
    }
    button {
      margin-top: 1em;
      padding: 0.5em 1em;
      font-size: 1em;
      background: #4caf50;
      color: white;
      border: none;
      cursor: pointer;
    }
    pre {
      background: #121212;
      padding: 1em;
      white-space: pre-wrap;
      border-left: 5px solid #4caf50;
    }
  </style>
</head>
<body>
  <h1>유기문어(有機文語)</h1>
  <textarea id="code" placeholder="여기에 유기문어 코드를 입력하세요."></textarea>
  <br />
  <button onclick="runYugimunu()">실행하기</button>
  <p style="margin-top: 1em; font-size: 0.9em;">
    프로그래밍 언어의 원작 소설이 궁금하다면?<br>
    <a href="https://novelpia.com/novel/21232" target="_blank" style="color:#f06292; font-weight:bold;">『유기무녀』 보러가기</a>
  </p>
  <h2>실행 결과</h2>
  <pre id="output"></pre>

<script>
window.runYugimunu = function() {
  const state = { 경민: 0, 한별: 0, 솔빈: 0, 츠카사: 0, 윤설: 0 };
  const isDead = n => ["한별", "솔빈"].includes(n);
  const isAlive = n => ["츠카사", "윤설"].includes(n);
  const enemies = { 한별: "솔빈", 솔빈: "한별", 츠카사: "윤설", 윤설: "츠카사" };
  const outputBox = document.getElementById("output");
  let outputBuffer = "";
  let i = 0, stack = [], skipping = false;
  const code = document.getElementById("code").value.split(/\n|\r/);

  function error(msg) { outputBuffer += `❗ ${msg}\n`; }
  function output(msg) { outputBuffer += `${msg}\n`; }

  while (i < code.length) {
    let line = code[i++].trim();
    if (!line || line.startsWith("#")) continue;
    if (skipping && !line.includes("생각을 그만뒀다")) continue;

    const ifMatch = line.match(/(\S+)이\s+"?(\S+?)"?은\s+"?(\S+?)"?을\s+(이해했다|이해하지 못했다|크다고|작다고)\s+생각했다/);
    if (ifMatch) {
      const [_, subject, left, right, op] = ifMatch;
      const lval = isNaN(left) ? (state[left] ?? left) : parseInt(left);
      const rval = isNaN(right) ? (state[right] ?? right) : parseInt(right);

      let result = false;
      if (typeof lval === "string" || typeof rval === "string") {
        if (op === "이해했다") result = lval === rval;
        else if (op === "이해하지 못했다") result = lval !== rval;
        else {
          error(`${subject}이 ${left}은 ${right}을 ${op} — 문자열에는 비교 불가.`);
          result = false;
        }
      } else {
        if (op === "이해했다") result = lval == rval;
        else if (op === "이해하지 못했다") result = lval != rval;
        else if (op === "크다고") result = lval > rval;
        else if (op === "작다고") result = lval < rval;
      }
      skipping = !result;
      stack.push(skipping);
      continue;
    }

    const action = line.match(/(\S+)이\s+(\S+)[을를]\s+(사랑했다|증오했다|껴안았다|밀어냈다|잊었다|말했다|들었다)/);
    if (!action) {
      error(`경민은 혼란에 빠졌다 — '${line}'은 알 수 없는 문장입니다.`);
      continue;
    }
    const [_, subj, obj, verb] = action;

    if (!(obj in state)) state[obj] = 0;
    if (subj === obj && !["말했다", "들었다", "잊었다"].includes(verb)) {
      error(`${subj}은 자신에게 감정을 적용할 수 없습니다.`);
      continue;
    }
    if (enemies[subj] === obj) {
      error(`${subj}과(와) ${obj}은 앙숙이라 함께 연산할 수 없습니다.`);
      continue;
    }
    const sDead = isDead(subj), oDead = isDead(obj);
    const sAlive = isAlive(subj), oAlive = isAlive(obj);

    switch (verb) {
      case "사랑했다":
        if ((sDead || oDead) && subj !== "경민") {
          error(`${verb}는 생존자 전용입니다.`); break;
        }
        state[obj] += 1; break;
      case "껴안았다":
        if ((sDead || oDead) && subj !== "경민") {
          error(`${verb}는 생존자 전용입니다.`); break;
        }
        state[obj] *= (state[subj] || 1); break;
      case "증오했다":
        if ((sAlive || oAlive) && subj !== "경민") {
          error(`${verb}는 사망자 전용입니다.`); break;
        }
        state[obj] -= 1; break;
      case "밀어냈다":
        if ((sAlive || oAlive) && subj !== "경민") {
          error(`${verb}는 사망자 전용입니다.`); break;
        }
        state[obj] = Math.floor(state[obj] / (state[subj] || 1)); break;
      case "잊었다":
        state[obj] = 0; break;
      case "말했다":
        if (obj in state) output(`${obj} = ${state[obj]}`);
        else output(obj);
        break;
      case "들었다":
        const val = prompt(`${obj} 값을 입력하세요:`);
        state[obj] = parseInt(val) || 0;
        break;
    }
  }
  outputBox.textContent = outputBuffer || "(출력 없음)";
}
</script>
</body>
</html>
