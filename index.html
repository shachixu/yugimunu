
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ìœ ê¸°ë¬¸ì–´ ì¸í„°í”„ë¦¬í„°</title>
  <style>
    body { font-family: 'Courier New', monospace; background: #121212; color: #f0f0f0; padding: 20px; }
    textarea { width: 100%; height: 200px; background: #1e1e1e; color: #f06292; padding: 10px; border: none; font-size: 16px; }
    button { padding: 10px 20px; background: #f06292; color: white; border: none; cursor: pointer; margin-top: 10px; }
    pre { background: #1e1e1e; padding: 10px; white-space: pre-wrap; word-wrap: break-word; }
  </style>
</head>
<body>
  <h2>ğŸ¥€ ìœ ê¸°ë¬¸ì–´ ì¸í„°í”„ë¦¬í„°</h2>
  <p>â€» ì›ì‘ ì†Œì„¤: <a href="https://novelpia.com/novel/21232" target="_blank" style="color:#f06292;font-weight:bold;">ã€ìœ ê¸°ë¬´ë…€ã€ ë³´ëŸ¬ê°€ê¸°</a></p>
  <textarea id="code" placeholder="ì—¬ê¸°ì— ìœ ê¸°ë¬¸ì–´ ì½”ë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”..."></textarea><br>
  <button id="runButton">ì‹¤í–‰í•˜ê¸°</button>
  <pre id="output"></pre>

  <script>
    const state = { "ê²½ë¯¼": 0, "í•œë³„": 0, "ì†”ë¹ˆ": 0, "ì¸ ì¹´ì‚¬": 0, "ìœ¤ì„¤": 0 };
    const isDead = name => ["í•œë³„", "ì†”ë¹ˆ"].includes(name);
    const isAlive = name => ["ì¸ ì¹´ì‚¬", "ìœ¤ì„¤"].includes(name);
    const enemies = { "í•œë³„": "ì†”ë¹ˆ", "ì†”ë¹ˆ": "í•œë³„", "ì¸ ì¹´ì‚¬": "ìœ¤ì„¤", "ìœ¤ì„¤": "ì¸ ì¹´ì‚¬" };
    let outputBuffer = "";

    function error(msg) { outputBuffer += `â— ${msg}\n`; }
    function output(msg) { outputBuffer += `\${msg}\n`; }

    document.getElementById("runButton").addEventListener("click", () => {
      const code = document.getElementById("code").value.trim().split(/\r?\n/);
      let stack = [], skipping = false;
      outputBuffer = "";

      for (let i = 0; i < code.length; i++) {
        let line = code[i].trim();
        if (!line || line.startsWith("//")) continue;
        line = normalizeSubject(line);

        if (/(\S+)ì´\s+.+ê³ \s+ìƒê°í–ˆë‹¤/.test(line)) {
  const conditionPattern = /(\S+)ì´\s+(.+?)ê³ \s+ìƒê°í–ˆë‹¤/;
  const compareOps = {
    "ì´í•´í–ˆë‹¤": "==",
    "ì´í•´í•˜ì§€ ëª»í–ˆë‹¤": "!=",
    "í¬ë‹¤ê³ ": ">",
    "ì‘ë‹¤ê³ ": "<",
    "í¬ë‹¤": ">",
    "ì‘ë‹¤": "<"
  };

  const [, subject, rawCond] = line.match(conditionPattern);
  let lastVarMatch = rawCond.match(/"([^"]+)"ì€/);
  let lastVar = lastVarMatch ? lastVarMatch[1] : null;

  const logicSplit = rawCond.split(/(?:ë˜í•œ|ë˜ëŠ”)/);
  const logicOps = [...rawCond.matchAll(/(?:ë˜í•œ|ë˜ëŠ”)/g)].map(m => m[0]);
  let conditions = [];

  for (let part of logicSplit) {
    let expr = part.trim();
    let handled = false;

    let strMatch = expr.match(/"([^"]+)"ì€\s+"([^"]+)"ì„\s*(ì´í•´í–ˆë‹¤|ì´í•´í•˜ì§€ ëª»í–ˆë‹¤)/);
    if (strMatch) {
      const [, left, right, op] = strMatch;
      conditions.push(\`(state["${left}"] ${compareOps[op]} state["${right}"])\`);
      lastVar = left;
      handled = true;
    }

    let numMatch = expr.match(/"([^"]+)"ì€\s+(\d+)ë³´ë‹¤\s*(í¬ë‹¤ê³ |ì‘ë‹¤ê³ |í¬ë‹¤|ì‘ë‹¤)/);
    if (!handled && numMatch) {
      const [, left, num, op] = numMatch;
      conditions.push(\`(state["${left}"] ${compareOps[op]} ${num})\`);
      lastVar = left;
      handled = true;
    }

    let shortMatch = expr.match(/(\d+)ë³´ë‹¤\s*(í¬ë‹¤ê³ |ì‘ë‹¤ê³ |í¬ë‹¤|ì‘ë‹¤)/);
    if (!handled && shortMatch && lastVar) {
      const [, num, op] = shortMatch;
      conditions.push(\`(state["${lastVar}"] ${compareOps[op]} ${num})\`);
      handled = true;
    }

    if (!handled) {
      error(\`â— ì¡°ê±´ í‰ê°€ ì˜¤ë¥˜: '${expr}'\`);
      stack.push(false);
      skipping = true;
      break;
    }
  }

  let conditionStr = conditions[0];
  for (let i = 1; i < conditions.length; i++) {
    const logic = logicOps[i - 1] === "ë˜í•œ" ? "&&" : "||";
    conditionStr += \` ${logic} ${conditions[i]}\`;
  }

  console.log("â–¶ rawCond:", rawCond);
  console.log("â–¶ conditionStr:", conditionStr);

  try {
    const result = eval(conditionStr);
    stack.push(result);
    skipping = !result;
  } catch (e) {
    error(\`ì¡°ê±´ í‰ê°€ ì˜¤ë¥˜: ${conditionStr}\`);
    stack.push(false);
    skipping = true;
  }
}

        if (skipping) {
          if (line.endsWith("ìƒê°ì„ ê·¸ë§Œë’€ë‹¤")) {
            skipping = false;
            stack.pop();
          }
          continue;
        }

        if (/ì€ ë§í–ˆë‹¤/.test(line)) {
          const msg = line.match(/"(.+?)"ì„ ë§í–ˆë‹¤/);
          if (msg) output(msg[1]);
        }

        if (/ì€ ë£¨í”„ë¥¼ ì‹œì‘í–ˆë‹¤/.test(line)) {
          const subject = line.match(/"?(\w+)"?\s*ì€ ë£¨í”„ë¥¼ ì‹œì‘í–ˆë‹¤/)[1];
          stack.push({ type: "loop", subject, index: i });
        }

        if (/ì€ ë£¨í”„ë¥¼ ì¢…ë£Œí–ˆë‹¤/.test(line)) {
          const loop = stack.pop();
          if (loop?.type === "loop" && state[loop.subject] > 0) {
            i = loop.index - 1;
            state[loop.subject]--;
          }
        }

        if (/ì€ ìƒê°ì„ ë°”ê¿¨ë‹¤/.test(line)) {
          skipping = !stack.pop();
          stack.push(!skipping);
        }

        if (/ì€ ìƒê°ì„ ê·¸ë§Œë’€ë‹¤/.test(line)) {
          stack.pop();
        }

        if (/ì€ \d+ì„ ì‚¬ë‘í–ˆë‹¤/.test(line)) {
          const [who, num] = line.split("ì€ ");
          if (!isDead(who)) state[who] += parseInt(num.match(/\d+/)[0]);
        }

        if (/ì€ \d+ì„ ì¦ì˜¤í–ˆë‹¤/.test(line)) {
          const [who, num] = line.split("ì€ ");
          if (!isAlive(who)) state[who] -= parseInt(num.match(/\d+/)[0]);
        }

        if (/ì€ \d+ì„ ê»´ì•ˆì•˜ë‹¤/.test(line)) {
          const [who, num] = line.split("ì€ ");
          if (!isDead(who)) state[who] *= parseInt(num.match(/\d+/)[0]);
        }

        if (/ì€ \d+ì„ ë°€ì–´ëƒˆë‹¤/.test(line)) {
          const [who, num] = line.split("ì€ ");
          if (!isAlive(who)) state[who] = Math.floor(state[who] / parseInt(num.match(/\d+/)[0]));
        }

        if (/ì€ ìŠì—ˆë‹¤/.test(line)) {
          const who = line.match(/"?(\w+)"?\s*ì€ ìŠì—ˆë‹¤/)[1];
          state[who] = 0;
        }

        if (/ëŠ” ìƒê°í–ˆë‹¤/.test(line)) {
          const cond = line.match(/(.+ëŠ” .+ê³  ìƒê°í–ˆë‹¤)/);
          if (cond) {
            error("ê²½ë¯¼ì€ í˜¼ë€ì— ë¹ ì¡Œë‹¤ â€” '" + cond[1] + "'ì€ ì•Œ ìˆ˜ ì—†ëŠ” ë¬¸ì¥ì…ë‹ˆë‹¤.");
          }
        }
      }

      for (const key in state) {
        output(`\${key} = \${state[key]}`);
      }

      document.getElementById("output").textContent = outputBuffer;
    });

    function normalizeSubject(line) {
      return line.replace(/â€œ|â€/g, '"').replace(/â€˜|â€™/g, "'").replace(/â€œ|â€/g, '"');
    }
  </script>
</body>
</html>
